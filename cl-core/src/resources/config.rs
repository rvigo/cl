use super::fs_wrapper;
use anyhow::{Context, Result};
use dirs::home_dir;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

const ROOT_DIR: &str = ".config/cl";
const COMMAND_FILE: &str = "commands.toml";
const CONFIG_FILE: &str = "config.toml";

// defaults
const DEFAULT_LOG_LEVEL: &LogLevel = &LogLevel::Error;
const DEFAULT_QUIET_MODE: bool = false;
const DEFAULT_HIGHLIGHT_MATCHES: bool = true;

const DEFAULT_FILE_MESSAGE: &str =
    "# This file is generated by `cl`. Please do not change it directly\n\n";

#[derive(Clone, Serialize, Deserialize)]
pub enum LogLevel {
    Debug,
    Info,
    Error,
}

impl From<&LogLevel> for String {
    fn from(log_level: &LogLevel) -> Self {
        match log_level {
            LogLevel::Debug => String::from("debug"),
            LogLevel::Info => String::from("info"),
            LogLevel::Error => String::from("error"),
        }
    }
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct Options {
    #[serde(skip_serializing_if = "Option::is_none", alias = "default_quiet_mode")]
    quiet_mode: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none", alias = "log_level")]
    log_level: Option<LogLevel>,
    #[serde(skip_serializing_if = "Option::is_none", alias = "highlight_matches")]
    highlight_matches: Option<bool>,
}

impl Options {
    pub fn new() -> Options {
        Self {
            quiet_mode: None,
            log_level: None,
            highlight_matches: None,
        }
    }

    pub fn get_highlight(&mut self) -> bool {
        self.highlight_matches.unwrap_or(DEFAULT_HIGHLIGHT_MATCHES)
    }

    pub fn set_highlight(&mut self, highlight: bool) {
        self.highlight_matches = Some(highlight);
    }

    pub fn get_log_level(&self) -> LogLevel {
        self.log_level
            .as_ref()
            .unwrap_or(DEFAULT_LOG_LEVEL)
            .to_owned()
    }

    pub fn set_log_level(&mut self, log_level: LogLevel) {
        self.log_level = Some(log_level);
    }

    pub fn get_quiet_mode(&self) -> bool {
        self.quiet_mode.unwrap_or(DEFAULT_QUIET_MODE)
    }

    pub fn set_quiet_mode(&mut self, quiet_mode: bool) {
        self.quiet_mode = Some(quiet_mode);
    }
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct Config {
    // serde `alias` should be removed in the future
    #[serde(alias = "app_home_dir")]
    root_dir: PathBuf,
    #[serde(skip_serializing_if = "Option::is_none", alias = "config_home_path")]
    config_file_path: Option<PathBuf>,
    #[serde(skip_serializing_if = "Option::is_none", alias = "command_file_path")]
    commands_file_path: Option<PathBuf>,
    options: Option<Options>,
}

impl Config {
    pub fn get_root_dir(&self) -> PathBuf {
        self.root_dir.to_owned()
    }

    pub fn get_options(&self) -> Options {
        self.options
            .as_ref()
            .map_or_else(Options::new, |options| options.to_owned())
    }

    pub fn get_command_file_path(&self) -> PathBuf {
        self.commands_file_path
            .as_ref()
            .map_or_else(|| self.get_root_dir().join(COMMAND_FILE), |p| p.to_owned())
    }

    pub fn get_config_file_path(&self) -> PathBuf {
        self.get_root_dir().join(CONFIG_FILE)
    }

    pub fn get_highlight(&self) -> bool {
        self.options
            .to_owned()
            .unwrap_or_else(Options::new)
            .get_highlight()
    }

    pub fn set_highlight(&mut self, highlight: bool) -> Result<()> {
        self.change_and_save(|config| config.ensure_options().set_highlight(highlight))
    }

    pub fn get_log_level(&self) -> LogLevel {
        self.options
            .to_owned()
            .unwrap_or_else(Options::new)
            .get_log_level()
    }

    pub fn set_log_level(&mut self, log_level: LogLevel) -> Result<()> {
        self.change_and_save(|config| config.ensure_options().set_log_level(log_level))
    }

    pub fn get_quiet_mode(&self) -> bool {
        self.options
            .to_owned()
            .unwrap_or_else(Options::new)
            .get_quiet_mode()
    }

    pub fn set_quiet_mode(&mut self, quiet_mode: bool) -> Result<()> {
        self.change_and_save(|config| config.ensure_options().set_quiet_mode(quiet_mode))
    }

    pub fn save(&self) -> Result<()> {
        let app_home_dir = self.get_root_dir();

        if !app_home_dir.exists() {
            fs_wrapper::create_dir_all(&app_home_dir)
                .context(format!("Cannot create {app_home_dir:?}"))?
        }

        let config_file_path = app_home_dir.join(self.get_config_file_path());
        let mut config_data = toml::to_string(self)?;

        config_data.insert_str(0, DEFAULT_FILE_MESSAGE);

        fs_wrapper::write(config_file_path, config_data)?;
        Ok(())
    }

    /// Loads the config file
    pub fn load() -> Result<Self> {
        let home = home_dir().context("Could not find home directory")?;
        let config_file_path = home.join(ROOT_DIR).join(CONFIG_FILE);
        if let Ok(config_data) = fs_wrapper::read_to_string(config_file_path) {
            if !config_data.is_empty() {
                let config: Self = toml::from_str(&config_data)?;
                return Ok(config);
            }
        }
        Self::new()
    }

    fn new() -> Result<Self> {
        let home_dir = home_dir().context("Could not find home directory")?;
        let root = home_dir.join(ROOT_DIR);
        let config = Self {
            root_dir: root.to_owned(),
            config_file_path: Some(root.join(CONFIG_FILE)),
            commands_file_path: Some(root.join(COMMAND_FILE)),
            options: Some(Options::new()),
        };
        config.save().context("Cannot save the config file")?;
        Ok(config)
    }

    fn ensure_options(&mut self) -> &mut Options {
        self.options.get_or_insert_with(Options::new)
    }

    fn change_and_save<F>(&mut self, f: F) -> Result<()>
    where
        F: FnOnce(&mut Self),
    {
        f(self);
        self.save()
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use std::{
        env::temp_dir,
        fs,
        sync::atomic::{AtomicUsize, Ordering},
    };

    fn get_id() -> usize {
        static COUNTER: AtomicUsize = AtomicUsize::new(1);
        COUNTER.fetch_add(1, Ordering::Relaxed)
    }

    fn builder() -> Config {
        let tmp = temp_dir();
        let config_dir = tmp.join(format!(".config{}", get_id()));
        Config {
            root_dir: config_dir.to_owned(),
            config_file_path: Some(config_dir.join(CONFIG_FILE)),
            commands_file_path: None,
            options: Some(Options {
                quiet_mode: None,
                log_level: None,
                highlight_matches: None,
            }),
        }
    }

    fn tear_down(config: Config) -> Result<()> {
        if config.config_file_path.as_ref().is_some()
            && config.config_file_path.as_ref().unwrap().exists()
        {
            fs::remove_file(config.config_file_path.as_ref().unwrap())?;
        }
        fs::remove_dir(config.get_root_dir()).unwrap();

        Ok(())
    }

    #[test]
    fn should_save_a_new_config() -> Result<()> {
        let config = builder();

        assert!(config.root_dir.try_exists().is_ok());
        assert_eq!(config.root_dir.try_exists().unwrap(), false);

        config.save()?;

        assert!(config.root_dir.try_exists().is_ok());
        assert_eq!(config.root_dir.try_exists().unwrap(), true);

        tear_down(config)
    }

    #[test]
    fn should_set_default_quiet_mode() -> Result<()> {
        let mut config = builder();
        config.save()?;

        assert_eq!(config.get_quiet_mode(), false);

        config.set_quiet_mode(true)?;

        assert_eq!(config.get_quiet_mode(), true);

        tear_down(config)
    }

    #[test]
    fn should_set_log_level() -> Result<()> {
        let mut config = builder();
        config.save()?;

        assert_eq!(
            String::from(&config.get_log_level()),
            String::from(&LogLevel::Error)
        );

        config.set_log_level(LogLevel::Debug)?;

        assert_eq!(
            String::from(&config.get_log_level()),
            String::from(&LogLevel::Debug)
        );

        tear_down(config)
    }

    #[test]
    fn should_set_highlight() -> Result<()> {
        let mut config = builder();
        config.save()?;

        assert_eq!(config.get_options().get_highlight(), true);

        config.set_highlight(false)?;

        assert_eq!(config.get_options().get_highlight(), false);

        // get default value in case of None
        config.options.as_mut().unwrap().highlight_matches = None;

        assert_eq!(config.get_options().get_highlight(), true);

        tear_down(config)
    }
}
