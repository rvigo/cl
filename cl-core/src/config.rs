use super::resources::fs_wrapper;
use crate::preferences::Preferences;
use anyhow::{Context, Result};
use dirs::home_dir;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

const ROOT_DIR: &str = ".config/cl";
const COMMAND_FILE: &str = "commands.toml";
const CONFIG_FILE: &str = "config.toml";

const DEFAULT_FILE_MESSAGE: &str =
    "# This file is generated by `cl`. Please do not change it directly\n\n";

#[derive(Clone, Serialize, Deserialize, Default)]
pub enum LogLevel {
    Debug,
    Info,
    #[default]
    Error,
}

impl From<&LogLevel> for String {
    fn from(log_level: &LogLevel) -> Self {
        match log_level {
            LogLevel::Debug => String::from("debug"),
            LogLevel::Info => String::from("info"),
            LogLevel::Error => String::from("error"),
        }
    }
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct Config {
    // serde `alias` should be removed in the future
    #[serde(alias = "app_home_dir")]
    root_dir: PathBuf,
    #[serde(skip_serializing_if = "Option::is_none", alias = "config_home_path")]
    config_file_path: Option<PathBuf>,
    #[serde(skip_serializing_if = "Option::is_none", alias = "command_file_path")]
    commands_file_path: Option<PathBuf>,
    #[serde(
        skip_serializing_if = "Option::is_none",
        alias = "options",
        rename = "preferences"
    )]
    preferences: Option<Preferences>,
}

impl Config {
    pub fn get_root_dir(&self) -> PathBuf {
        self.root_dir.to_owned()
    }

    pub fn preferences(&self) -> Preferences {
        self.preferences
            .as_ref()
            .map_or_else(Preferences::default, |p| p.to_owned())
    }

    pub fn preferences_mut(&mut self) -> &mut Preferences {
        self.preferences.get_or_insert_with(Preferences::default)
    }

    pub fn command_file_path(&self) -> PathBuf {
        self.commands_file_path
            .as_ref()
            .map_or_else(|| self.get_root_dir().join(COMMAND_FILE), |p| p.to_owned())
    }

    pub fn config_file_path(&self) -> PathBuf {
        self.get_root_dir().join(CONFIG_FILE)
    }

    /// Loads the config file
    pub fn load() -> Result<Self> {
        let home = home_dir().context("Could not find home directory")?;
        let config_file_path = home.join(ROOT_DIR).join(CONFIG_FILE);
        if let Ok(config_data) = fs_wrapper::read_to_string(config_file_path) {
            if !config_data.is_empty() {
                let config: Self = toml::from_str(&config_data)?;
                return Ok(config);
            }
        }
        Self::new()
    }

    pub fn change_and_save<F>(&mut self, f: F) -> Result<()>
    where
        F: FnOnce(&mut Self),
    {
        f(self);
        self.save()
    }

    fn new() -> Result<Self> {
        let home_dir = home_dir().context("Could not find home directory")?;
        let root = home_dir.join(ROOT_DIR);
        let config = Self {
            root_dir: root.to_owned(),
            config_file_path: Some(root.join(CONFIG_FILE)),
            commands_file_path: Some(root.join(COMMAND_FILE)),
            preferences: Some(Preferences::default()),
        };
        config.save().context("Cannot save the config file")?;
        Ok(config)
    }

    fn save(&self) -> Result<()> {
        let app_home_dir = self.get_root_dir();

        if !app_home_dir.exists() {
            fs_wrapper::create_dir_all(&app_home_dir)
                .context(format!("Cannot create {app_home_dir:?}"))?
        }

        let config_file_path = app_home_dir.join(self.config_file_path());
        let mut config_data = toml::to_string(self)?;

        config_data.insert_str(0, DEFAULT_FILE_MESSAGE);

        fs_wrapper::write(config_file_path, config_data)?;
        Ok(())
    }
}
